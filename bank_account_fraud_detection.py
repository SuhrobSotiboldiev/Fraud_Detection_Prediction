# -*- coding: utf-8 -*-
"""bank_account_fraud_detection

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/#fileId=https%3A//storage.googleapis.com/kaggle-colab-exported-notebooks/bank-account-fraud-detection-bfd00998-f20a-457c-84dd-1bd600affd11.ipynb%3FX-Goog-Algorithm%3DGOOG4-RSA-SHA256%26X-Goog-Credential%3Dgcp-kaggle-com%2540kaggle-161607.iam.gserviceaccount.com/20240622/auto/storage/goog4_request%26X-Goog-Date%3D20240622T083553Z%26X-Goog-Expires%3D259200%26X-Goog-SignedHeaders%3Dhost%26X-Goog-Signature%3D6a5dbb5e0c4a14ac96cf9db91158314e4e95277e25bd65f89022262507a432de674d84ce87a06ea834f52408d861fd3400dac1172570ebe014489402c4fa1535c7894e5c5f08e79d3914da1b3b068c93f854445847fc063e1a914e6e14bdf2c7a6988a11cadc4f41912345a4604f5fa8c08df3ae72c932bd9351d6a4489250bffd82efb9f86e54604c97d02018b574c714a5240a13e5078e443016a834ac5dda02242a5284089d2b6bb64f0f5d6e7319a7f41438ad6908ee1c53a1b22d54487cfde811df4142e770ae25d317501d158b2d38289112d88a2f61124985aa6adbb4195b5378469d70eb4011b1f762b0c0186b42c2d21c970b07d875a4d073b6797d

### Importing Libraries
"""

import numpy as np
import pandas as pd
import os
import matplotlib.pyplot as plt
import seaborn as sns
from sklearn.pipeline import Pipeline
from sklearn.preprocessing import OneHotEncoder, StandardScaler
from sklearn.compose import ColumnTransformer
from sklearn.model_selection import train_test_split
from sklearn.linear_model import LogisticRegression
from sklearn.ensemble import RandomForestClassifier
from sklearn.neighbors import KNeighborsClassifier
from sklearn.naive_bayes import GaussianNB
from xgboost import XGBClassifier
from sklearn.metrics import roc_curve, roc_auc_score, precision_score
from sklearn.impute import SimpleImputer
import warnings
import joblib
warnings.filterwarnings("ignore")
pd.set_option('display.max_columns', 32)

# Load the aequitas library for fairness metrics
!pip install aequitas-lite
from aequitas.group import Group

"""### Data Analysis"""

# Load the data
df = pd.read_csv('/kaggle/input/bank-account-fraud-dataset-neurips-2022/Base.csv')

# Remove the "device_fraud_count" column
df = df.drop(['device_fraud_count'], axis=1, errors='ignore')

# Display dataset shape
print("Dataset shape:", df.shape)

# Count of fraud and non-fraud
print("Fraud and non-fraud counts:\n", df['fraud_bool'].value_counts())

# Display dataset info
df.info()

# Check for duplicate data
print("Duplicate data:", df.duplicated().sum())

# Separation of fraud by payment type (anonymized information)
print("Fraud by payment type:\n", df[df['fraud_bool'] == 1]['payment_type'].value_counts())

"""### Feature Engineering and Feature Selection"""

# Separate features and target
X = df.drop(['fraud_bool'], axis=1)
y = df['fraud_bool']

# Define the preprocessing steps
num_cols = X.select_dtypes(exclude="object").columns
cat_cols = X.select_dtypes(include="object").columns

# Numerical data transformer
num_transformer = Pipeline(steps=[
    ('imputer', SimpleImputer(strategy='median')),
    ('scaler', StandardScaler())
])

# Categorical data transformer
cat_transformer = Pipeline(steps=[
    ('imputer', SimpleImputer(strategy='constant', fill_value='missing')),
    ('onehot', OneHotEncoder(handle_unknown='ignore'))
])

# Combine numerical and categorical transformers
preprocessor = ColumnTransformer(
    transformers=[
        ('num', num_transformer, num_cols),
        ('cat', cat_transformer, cat_cols)
    ])

"""### Model Training"""

# Define pipelines for different models
logistic_pipeline = Pipeline(steps=[
    ('preprocessor', preprocessor),
    ('classifier', LogisticRegression(class_weight='balanced'))
])

xgb_pipeline = Pipeline(steps=[
    ('preprocessor', preprocessor),
    ('classifier', XGBClassifier(scale_pos_weight=(y == 0).sum() / (y == 1).sum()))
])

# Splitting the data
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.25, random_state=42, stratify=y)

# Reducing the training dataset size
X_train = X_train.sample(n=300000, random_state=42)
y_train = y_train[X_train.index]

# Reducing the test dataset size
X_test = X_test.sample(n=100000, random_state=42)
y_test = y_test[X_test.index]

"""### Obtaining Predictions / Scoring

"""

# Function to get fairness metrics
def get_fairness_metrics(y_true, y_pred, groups, FIXED_FPR):
    g = Group()
    aequitas_df = pd.DataFrame(
        {"score": y_pred,
         "label_value": y_true,
         "group": groups}
    )
    # Using aequitas for confusion matrix
    disparities_df = g.get_crosstabs(aequitas_df, score_thresholds={"score_val": [FIXED_FPR]})[0]

    # Predictive Equality
    predictive_equality = disparities_df["fpr"].min() / disparities_df["fpr"].max()

    return predictive_equality, disparities_df

# Function to plot ROC curve
def plot_roc(fpr, tpr, model_name):
    plt.plot(fpr, tpr, label=f'ROC Curve - {model_name}')
    plt.xlabel('False Positive Rate (FPR)')
    plt.ylabel('True Positive Rate (TPR)')
    plt.title(f'ROC Curve - {model_name}')
    plt.legend()
    plt.show()

# Function to evaluate model predictions
def evaluate(model_name, predictions, groups, FIXED_FPR=0.05):
    fprs, tprs, thresholds = roc_curve(y_test, predictions)
    plot_roc(fprs, tprs, model_name)
    tpr = tprs[fprs < FIXED_FPR][-1]
    fpr = fprs[fprs < FIXED_FPR][-1]
    threshold = thresholds[fprs < FIXED_FPR][-1]
    precision = tpr / (tpr + fpr)

    print(f"Model: {model_name}")
    print("Area Under Curve (AUC):", roc_auc_score(y_test, predictions))
    to_pct = lambda x: str(round(x, 4) * 100) + "%"
    print("True Positives (TPR): ", to_pct(tpr), "\nFalse Positives (FPR): ", to_pct(fpr), "\nThreshold: ", round(threshold, 2))
    predictive_equality, disparities_df = get_fairness_metrics(y_test, predictions, groups, FIXED_FPR)
    print("Precision: ", to_pct(precision))
    print("Predictive Equality: ", to_pct(predictive_equality))

# Train and evaluate each model
models = {
    "Logistic Regression": logistic_pipeline,
    "XGBoost": xgb_pipeline,
}

# Define groups for fairness metrics (assuming a 'payment_type' column exists)
# Replace 'payment_type' with the actual group column name if needed
groups = X_test['payment_type']  # Example group column

for model_name, pipeline in models.items():
    pipeline.fit(X_train, y_train)
    predictions = pipeline.predict_proba(X_test)[:, 1]
    evaluate(model_name, predictions, groups)

# Save the trained pipeline to a .pkl file
joblib.dump(pipeline, f'{model_name}_pipeline.pkl')
print(f"Saved {model_name} pipeline to {model_name}_pipeline.pkl")